---
title: "Day 1 Companion: Intro to R and Basic Plots"
output:
  md_document:
    variant: gfm
---

> **Today:** set up folders, load packages, introduction to R variables and data structures, data frames and tibbles, key data manipulation verbs (`select`, `filter`, `mutate`, and `arrange`), and some basic plots.

# 0. Setup

The first chunk below is the code from Brightspace to install the required packages. 
BEFORE you run it: please make a folder  the "Files" tab in the bottom right of RStudio is a folder where you will work out of for the assignment. In class we made one called `ds_iai` and opened a new R Markdown file inside it.

```{r, chunk-0}
# wd = working directory 
# directory is a fancy word for folder
getwd() # where are we working from?
```

```{r, chunk-0.1}
# 2.1 install the groundhog package and other packages needed for the course
# install.packages('groundhog', version = '3.2.3')
# install.packages('tidyverse', version = '2.0.0')
# install.packages('here', version = '1.0.2')

# 2.2. attach the groundhog package, to activate taking a "snapshot" of versions
library(groundhog)

# 2.3 pick october 1st as a common reference date and install the packages
groundhog.library(c('here','tidyverse'), "2025-10-01")
```

Some of you had issues with the `groundhog` package. If that's you: please forget about the `groundhog` package.
This package only serves to help keep the other packages (software libraries) using a correct and consistent version.

As long as you have the `tidyverse` and `here` packages installed (and your versions aren't really old) -- you should be fine.

```{r, chunk-0.2}
# if that still doesn't work: just make sure you have the tidyverse and here packages installed
# install.packages('tidyverse', version = '2.0.0')
# install.packages('here', version = '1.0.2')

# and in the very worst case, try without the version argument, and then use sessionInfo() to check what version you use
# library(tidyverse)
# library(here)
# sessionInfo()
```

# 1. Variables and vectors

There are several "types" of variables in R, 
- chr: characters or "strings"
- num: numeric, can be either integers (1, 2, 3) or double (1, 1.21), sometimes called a "continuous" variable
- fct: factor, a categorical variable which can be chr or num type! sometimes called a "discrete" variable

We'll explore these more when we look at real clinical patient data in the next days.

```{r chunk-1}
x <- "hello" # single string, saved as x
y <- c("my", "first", "vector") # vector of strings, saved as y
z <- c(1, 2, 8, 4) # vector of integers (num), saved as z

# how are factors different than numeric vectors
w <- as_factor(z)
# alternatively:
# w <- factor(z, levels = sort(z))
# bonus: how is the line (function) below different from those above, and why would we (generally) prefer those above?
# w <- as.factor(z)

# how to learn about your variables
typeof(x)
class(x)
typeof(z)
length(y)
levels(w)

# how to find help
?mean
help.search("median")
```

PS: in general, it's better to give variables informative names! (Not x and y)

# 2. Operators and functions

Operators and functions are two critical concepts to "do" things in R. Operators are symbols that perform specific actions, while functions are named commands that take inputs (called "arguments") in parentheses, and do more complex tasks.

We started the coding demo on day 1 with a function -- `getwd()`, followed by `here()`, which does virtually the same thing. The five lines under "# how to learn about your variables" in the code chunk above are also functions.

We also discussed a few operators, which you'll be comfortable with by the end of the assignment:

- the assignment operator is a backwards arrow used to assign things (`variable_name <- variable_value`)
- the pipe operator is used to chain or combine multiple functions can either be %>% or |>
- the plus operator is used after a `ggplot()` function has been invoked to add plot options (layers, as we'll call them later)

```{r chunk-2}
# basic functions for numeric vectors
z_mean <- mean(z)
z_med <- median(z)

# print
z_mean
z_med

# these both give warnings, why?
mean(y) 
mean(w) 

# putting it all together
weights <- c(23.5, 24.1, 23.8, 24.3)  # <- is the assignment operator
average_weight <- mean(weights)       # mean() is a function
difference <- 24.5 - average_weight   # - is the subtraction operator
```

Tip: one final operator that is less common (not part of this assignment) but useful to know in R is the :: operator. It is used to invoke a function from a specific package. For example, instead of loading the `here` package (`library(here)`) and then calling the `here()` function, you could just type `here::here()` and R will pull the right function. 

# 3. Data frames and tibbles

Data frames are the most common data structure you'll encounter doing real data analysis in R -- think of it as the R version of an Excel table. It is similar to a matrix in that it also has row and column attributes, but 

There are several built-in datasets in R: `mtcars` (cars) and `iris` (flowers) are two of the most popular. In class and in the example we worked with `mtcars` -- complete the chunks below with `iris` for a bit more of a challenge.

```{r chunk-3}
# We'll start with a built-in dataset (a data.frame)
df <- mtcars
# df <- iris

# prints the first 6 rows of any data frame object
head(df)

# accession with [row, column] indices, starting at 1, not 0
df[1,1]

# other things to look at 
dim(df)
rownames(df)

# glimpse is a useful function, especially for data frames which do not give an overview of variable types
glimpse(df)
```

The tidyverse has its own "class" or type of data frame (named after the package it comes from) that we discussed: a `tibble`. This is functionally equivalent to a data frame, but it makes viewing a little more pleasant (especially in the console), which will become important once we get into "bigger" data in the coming days. 

Data frames have rownames and tibbles don't! So we have to use a special command, `rownames_to_column()` when saving one of the built-in datasets as a variable.

```{r chunk-3.1}
# why not this?
# cars <- as_tibble(df)

# correct way
cars <- df |> 
  rownames_to_column(var = "car_model") |>
  as_tibble()

cars
```

## Core verbs

Now think back to an Excel table -- what are some things you do with one of those when you're looking for something? Think of some verbs, imagine typing those instructions out to someone... The `tidyverse` functions for manipulating data in R are designed to be intuitive. 

The core four:

- `select()` selects whichever columns you tell it, either by name or index (number)
- `filter()` filters based on whatever criteria you give it (based on the columns you actually have or make)
- `mutate()` changes existing columns or creates new ones (think of calculations and transformations, etc)
- `arrange()` arranges or sorts the visual output based on whichever column(s) you give it

Often, we will use these in combination with one another, and/or one after another, which is why the pipe operator (|> or %>%) becomes so handy.

Fun fact: the pipe operator is possible because the functions we will learn in the `tidyverse` are standardized to take data frames as the first argument (input variable). (Confirm this and answer some questions for your future self by typing `?select` !)

```{r chunk-3.3}
# select/filter/mutate examples - play around with these!
df_small <- cars |>
  select(car_model, mpg, cyl, hp) |>
  filter(cyl %in% c(4, 6)) |>
  # right now, cyl is a number so we can also do:
  # filter(cyl <= 6) |> 
  mutate(hp_per_cyl = hp / cyl) |>
  arrange(desc(hp))

df_small |> select(car_model, hp_per_cyl, everything())
```

# 4. The most important types of plots

Data visualization only got a very brief intro on Day 1. It will get its own formal introduction on and be the focus of Day 2, so this section and the next are more preparatory than anything.

First, let's create a folder (named results or whatever you'd like to call it) inside of the folder we are working in for the assignment, using the `here()` function to build up a filepath string.

```{r chunk-4}
# here takes the strings that you give it and pastes them together to make a proper filename for your computer
results_path <- here('results') # one folder
results_path <- here('results','day-1') # subfolder, may need to add recursive=TRUE to dir.create

# bonus: try timestamping your folders
# today() is a function from the lubridate package (not part of core tidyverse) which we can still run thi
# results_path <- here('results', lubridate::today())

# whatever you decide to call it, check that results_path is a real filepath on your computer then create it
dir.create(results_path)
```

How to plot our data? First, need to ask what you would like to show (more on this to come)...

  1. Relationship? => scatter plot with `geom_point()`
  2. Distribution? => histogram with `geom_histogram()` or `geom_density()`
  3. Comparison? => boxplot with `geom_boxplot()`
  4. Composition? => stacked bar with `geom_bar()`

Check out the cheatsheet for more options and details: https://posit.co/wp-content/uploads/2022/10/data-visualization-1.pdf

In the following chunk, play around with colors and shapes (use the help to figure out how if needed!)

```{r chunk-4.1}
# to visualize distribution of numeric variables: geom_histogram
df |>
  ggplot(aes(x = mpg)) +
  geom_histogram(bins = 20) +
  labs(title = "Distribution of MPG")

# to visualize distribution of categorical variables: geom_bar (not stacked)
df |>
  # mutate(am = as_factor(am)) |>
  ggplot(aes(x = am)) +
  geom_bar() +
  labs(title = "Distribution of Transmission Types")

# Boxplot of mpg by cylinders (+ jittered points)
df |>
  ggplot(aes(x = factor(cyl), y = mpg)) +
  geom_boxplot() +
  geom_point() +
  # geom_jitter(width = 0.2, alpha = 0.6) + 
  labs(x = "Cylinders", y = "MPG", title = "MPG by Cylinder Count")

# Scatter (no smoothing)
# in class we colored by cyl, which we made a factor -- try that on your own here
df |>
  ggplot(aes(x = hp, y = mpg)) +
  geom_point() + #scatter plots are ALWAYS geom_point() not geom_jitter()
  labs(x = "Horsepower", y = "MPG", title = "MPG vs Horsepower") +
  theme_minimal()
```

# 5. Save a figure (practice using a project path)

If you've completed section 4 above and created a results folder and some plots, it's time to save them.

First, saving in our R environments by assigning them to a variable (none of the plots above are).

Then, using a function called `ggsave()` which takes arguments such as the plot variable name, a filename variable, width, and height (and more -- check `?ggsave`)

```{r chunk-5}
p <- ggplot(df, aes(hp, mpg)) + geom_point()

name_to_save <- here(results_path, "d1_scatter.png")

ggsave(filename = name_to_save, plot = p, width = 5, height = 5)
```

# Exercises: Penguins (Data Frames & Visualizations)

Use the same verbs and plotting steps from today: `select()`, `filter()`, `mutate()`, `arrange()`, and `ggplot()` + `geom_xxx()` + `labs()`.

It’s OK if plots print messages about removed rows — the dataset has some missing values.

## 1) Quick scan (structure & missingness)

How many rows/columns are in `penguins`?
Which variables are numeric vs. categorical?
Which columns visibly include missing (NA) values?

```{r}
penguins
head(penguins)
```

## 2) Focus on one species (filter, select, arrange)

Keep only Adelie rows; store as `adelie_tbl`.
Keep just: `bill_len`, `bill_dep`, `flipper_len`, `body_mass`, `year`.
Sort descending by `body_mass`.

Question: about how many Adelie penguins are over 4000 g?

```{r}
# YOUR CODE HERE
```

## 3) Derived variable (mutate)

In `adelie_tbl`, create `bill_ratio` = `bill_len` / `bill_dep`.
Sort by `bill_ratio` (largest first).

Question: what does a larger `bill_ratio` suggest?

```{r}
# YOUR CODE HERE
```

## 4) Relationship plot (scatter)

Make a scatter plot of bill length vs body mass. Color points by species.
Add a clear title and axis labels with labs().
Save your image to the results folder we made and use a descriptive name.

```{r}
# YOUR CODE HERE
```
